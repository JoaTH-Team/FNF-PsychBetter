package backend;

import openfl.display.Sprite;
import flixel.system.FlxAssets;

class FunkinSoundTray extends Sprite // Generated by Online Haxe Code Generator bcs i suck ass on this Class | Very Edited to make it look like base game
{
    ///// Customization /////
    var imagePath = 'soundTray/'; // This is Were your images are, you can leave it empty if it just in the images folder.
    var volumeImages = [
        'volumebox',
        'bars_0',
        'bars_1',
        'bars_2',
        'bars_3',
        'bars_4',
        'bars_5',
        'bars_6',
        'bars_7',
        'bars_8',
        'bars_9',
        'bars_10'
    ];
    var dumbVolumeImages = [
        'soundTray_0',
        'soundTray_1',
        'soundTray_2',
        'soundTray_3',
        'soundTray_4',
        'soundTray_5',
        'soundTray_6',
        'soundTray_7',
        'soundTray_8',
        'soundTray_9',
        'soundTray_10'
    ];

    var soundPath = 'soundTray/'; // This is Were your sounds are, you can leave it empty if it just in the sounds folder.
    var volumeSounds = [
        'Volup',
        'Voldown',
        'VolMAX'
    ];

    var oneImageTray = false; // If game refuses to make the static images stay loaded, enable this...
    var trayScale = 0.6; // Idk why Base Game Sound Tray images are so big...
    var defaultStayTime = 1; // How Long you want the SoundTray to stay visible.

    ///// Don't Change any of this below unless you know what you are doing /////
    var makeTray = true;
    public function new()
    {
        super();

        // Image Checker bcs if it fails, it gives Null Object.
        var imageTable = !oneImageTray ? volumeImages : dumbVolumeImages;
        for(i in 0...imageTable.length)
        {
            if (!Paths.fileExists('images/$imagePath${imageTable[i]}.png', IMAGE, false)) {
                makeTray = false;
                trace('images/$imagePath${imageTable[i]}.png was not Found.');
            }
        }
        // Sound Checker.
        for(i in 0...volumeSounds.length)
        {
            if (!Paths.fileExists('sounds/$soundPath${volumeSounds[i]}.ogg', SOUND, false)) {
                trace('sounds/$soundPath${volumeSounds[i]}.ogg was not Found | Using Flixel default sound for this Specific Action.');
            }
        }
        if(makeTray) createTray();
    }

    var fill:Sprite;
    var fillImage = null;

    var bgNum = 0;
    private function createTray():Void
    {
        FlxG.sound.soundTrayEnabled = false; // Custom | flixel.system.ui.FlxSoundTray - flixel.system.frontEnds.SoundFrontEnd

        var trayHeight = 0;
        if(!oneImageTray) {
            var bgImage = null;
            var backingFillImage = null;
            if(bgImage == null) {
                bgImage = Paths.image('$imagePath${volumeImages[0]}', false);
                Paths.excludeAsset(Paths.getPath('images/$imagePath${volumeImages[0]}.png', IMAGE));
                bgImage.bitmap.lock();
            }
            if(backingFillImage == null) {
                backingFillImage = Paths.image('$imagePath${volumeImages[volumeImages.length-1]}', false);
                Paths.excludeAsset(Paths.getPath('images/$imagePath${volumeImages[volumeImages.length-1]}.png', IMAGE));
                backingFillImage.bitmap.lock();
            }

            // Soundtray Background (volumebox)
            var background = new Sprite();
            background.graphics.beginBitmapFill(bgImage.bitmap, null, false);
            background.graphics.drawRect(0, 0, bgImage.width, bgImage.height);
            addChild(background);

            trayHeight = bgImage.height;
            bgNum = 1;

            // Soundtray Bars
            var backingFill = new Sprite();
            backingFill.graphics.beginBitmapFill(backingFillImage.bitmap, null, false);
            backingFill.graphics.drawRect(0, 0, backingFillImage.width, backingFillImage.height);
            backingFill.x = (bgImage.width - backingFillImage.width) / 2;
            backingFill.y = (bgImage.height - backingFillImage.height) - 70;
            backingFill.alpha = 0.4;
            addChild(backingFill);

            /////////////////////////

            fill = new Sprite();
            fill.x = backingFill.x;
            fill.y = backingFill.y;
            addChild(fill);
        }
        else
        {
            fillImage = Paths.image('$imagePath${dumbVolumeImages[0]}', false);

            fill = new Sprite();
            addChild(fill);

            trayHeight = fillImage.height;
        }

        scaleX = trayScale;
        scaleY = trayScale;

        y = -trayHeight - 10; // Hides the SoundTray | this.height doesnt fully hide the tray for some reason...
        updateFill(); // Update Fill to Current Volume
    }

    var curVolume = 0;
    static var isMuted:Bool = false;
    private function updateFill():Void
    {   
        curVolume = Math.round(FlxG.sound.volume * 10);
        var number = !isMuted ? curVolume : 0;

        if(!oneImageTray) fillImage = Paths.image('$imagePath${volumeImages[bgNum+number]}', false);
        else fillImage = Paths.image('$imagePath${dumbVolumeImages[number]}', false);
        // trace('Current Volume: $number');

        fill.graphics.clear();
        fill.graphics.beginBitmapFill(fillImage.bitmap, null, false);
        fill.graphics.drawRect(0, 0, fillImage.width, fillImage.height);
        
        graphics.endFill();

        FlxG.save.data.volume = curVolume / 10;
        FlxG.save.data.muted = isMuted;
        FlxG.save.flush();
    }
    
    var stayTime:Float = 0;
    var lerpYPos:Float = 0;
    var alphaTarget:Float = 0;
    var lowerStayTime:Bool = false;
    private override function __enterFrame(deltaTime:Float):Void
    {
        if(!makeTray) return;

        x = FlxG.stage.window.width / 2 - width/2; // Center X that SoundTray, is in __enterFrame in case people scale the windows.
        y = FlxMath.lerp(y, lerpYPos, 0.1); // Something y related that base game does
        alpha = FlxMath.lerp(alpha, alphaTarget, 0.25); // Something alpha related that base game does
        
        if (FlxG.keys.anyJustPressed(FlxG.sound.volumeUpKeys) || FlxG.keys.anyJustPressed(FlxG.sound.volumeDownKeys) || FlxG.keys.anyJustPressed(FlxG.sound.muteKeys)) {
            lowerStayTime = false;
            stayTime = defaultStayTime;
        }

        var sound = null;
        if (FlxG.keys.anyJustPressed(FlxG.sound.volumeUpKeys))
        {
            isMuted = false;
            if(curVolume == 10 && Paths.fileExists('sounds/$soundPath${volumeSounds[2]}.ogg', SOUND, false))
            {
                sound = Paths.sound('$soundPath${volumeSounds[2]}');
            }
            else
            {
                sound = Paths.fileExists('sounds/$soundPath${volumeSounds[0]}.ogg', SOUND, false) ? Paths.sound('$soundPath${volumeSounds[0]}') : FlxAssets.getSound("flixel/sounds/beep");
            }
        }
        else if (FlxG.keys.anyJustPressed(FlxG.sound.volumeDownKeys))
        {
            isMuted = false;
            sound = Paths.fileExists('sounds/$soundPath${volumeSounds[1]}.ogg', SOUND, false) ? Paths.sound('$soundPath${volumeSounds[1]}') : FlxAssets.getSound("flixel/sounds/beep");
        }
        else if (FlxG.keys.anyJustPressed(FlxG.sound.muteKeys))
        {
            isMuted = !isMuted;
        }
        if (sound != null) FlxG.sound.load(sound).play();

        var elapsed = deltaTime / 1000;
        if (FlxG.keys.anyJustReleased(FlxG.sound.volumeUpKeys) || FlxG.keys.anyJustReleased(FlxG.sound.volumeDownKeys) || FlxG.keys.anyJustReleased(FlxG.sound.muteKeys)) {
            lowerStayTime = true;
            updateFill();
        }

        if(stayTime > 0) { // When you Release Any Volume Key
            if(lowerStayTime) stayTime = Math.max(stayTime - elapsed, 0);
            alphaTarget = 1;
            lerpYPos = 10;
        } else if(y >= -height) {
            alphaTarget = 0;
            lerpYPos = -height - 10;
        }
    }
}